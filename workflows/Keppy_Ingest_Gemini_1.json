{
  "name": "Pinball Leaderboard Ingestion (9-Step)",
  "nodes": [
    {
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "everyMinute",
              "value": 10
            }
          ]
        }
      },
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        250,
        -100
      ],
      "name": "1. Schedule Trigger (Every 10 Mins)"
    },
    {
      "parameters": {
        "url": "https://api.prd.sternpinball.io/api/v1/portal/leaderboards/?event_code=hJjW-WXu-oCGQ&event_state=current&format=json",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        450,
        -100
      ],
      "name": "2. Fetch Data (Stern API)"
    },
    {
      "parameters": {
        "functionCode": "// **CRITICAL: Implement Custom JS Logic Here**\n\nconst rawResponse = $json;\nconst fetchedAt = new Date().toISOString();\nconst leaderboard = rawResponse.leaderboard;\n\n// 1. Prepare Metadata\nconst eventCode = leaderboard.code || 'hJjW-WXu-oCGQ';\nconst startDate = leaderboard.start_date;\nconst stopDate = leaderboard.stop_date;\n\n// 2. Map Machine Codes (CRITICAL for FKs)\nconst machineMap = leaderboard.titles.reduce((acc, title) => {\n  acc[title.title_name] = title.title_code; // e.g., 'Batman '66' -> 'BAT'\n  return acc;\n}, {});\n\n// 3. Flatten and Structure Scores\nconst structuredScores = leaderboard.scores.map(score => {\n  const machineId = machineMap[score.title_name];\n\n  // API does not provide a score timestamp, so we use the execution time (fetchedAt) as date_set.\n  return {\n    player_id: score.username, // Using username as the stable player_id\n    machine_id: machineId,\n    high_score: score.score,\n    date_set: fetchedAt, // The time of the API pull\n    event_code: eventCode,\n    display_name: score.username,\n    avatar_url: score.avatar_path\n  };\n});\n\n// The first output item will contain the metadata for downstream nodes (Recalculate)\n// The second item will be the array of structured scores for the filtering/ingestion steps\n\nreturn [\n  { json: { event_code: eventCode, start_date: startDate, stop_date: stopDate, raw_response: rawResponse, fetched_at: fetchedAt } },\n  ...structuredScores.map(score => ({ json: score }))\n];"
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        650,
        -100
      ],
      "name": "3. Audit & Prepare Data (Extract/Flatten)"
    },
    {
      "parameters": {
        "query": "INSERT INTO Api_Snapshots (raw_response, fetched_at, event_code) \nVALUES ($1, $2::TIMESTAMPTZ, $3);",
        "additionalFields": {
          "mode": "singleQuery",
          "queryParams": "={{$json.raw_response}},{{$json.fetched_at}},{{$json.event_code}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1.1,
      "position": [
        650,
        -250
      ],
      "name": "3A. Audit: Save Raw Snapshot",
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_NAME",
          "name": "YOUR_POSTGRES_CREDENTIAL_NAME"
        }
      }
    },
    {
      "parameters": {
        "query": "SELECT player_id FROM Events WHERE event_code = $1;",
        "additionalFields": {
          "mode": "singleQuery",
          "queryParams": "={{$json.event_code}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1.1,
      "position": [
        850,
        -100
      ],
      "name": "4. Event Validation (Check Events Table)",
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_NAME",
          "name": "YOUR_POSTGRES_CREDENTIAL_NAME"
        }
      }
    },
    {
      "parameters": {
        "query": "INSERT INTO Players (player_id, display_name, avatar_url, last_seen) \nVALUES ($1, $2, $3, NOW())\nON CONFLICT (player_id) DO UPDATE SET \n  display_name = EXCLUDED.display_name,\n  avatar_url = EXCLUDED.avatar_url,\n  last_seen = NOW();\n  \nINSERT INTO Machines (machine_id, machine_name) \nVALUES ($4, $5)\nON CONFLICT (machine_id) DO NOTHING;",
        "additionalFields": {
          "mode": "independently",
          "queryParams": "={{$json.player_id}},{{$json.display_name}},{{$json.avatar_url}},{{$json.machine_id}},{{$json.machine_id}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1.1,
      "position": [
        1050,
        -100
      ],
      "name": "5. Player/Machine UPSERT",
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_NAME",
          "name": "YOUR_POSTGRES_CREDENTIAL_NAME"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// **CRITICAL: Implement Smart Filtering Query Here**\n\nconst newItems = [];\n\nfor (const item of $input.all()) {\n  const score = item.json.high_score;\n  const playerId = item.json.player_id;\n  const machineId = item.json.machine_id;\n  const eventCode = item.json.event_code;\n\n  // In a real n8n Function node, you would execute an external query here\n  // to get the max existing score for this player/machine/event combination.\n  \n  // Pseudocode for the logic:\n  // const result = await this.executeSql('SELECT MAX(high_score) FROM High_Scores_Archive WHERE player_id = $1 AND machine_id = $2 AND event_code = $3', [playerId, machineId, eventCode]);\n  // const lastArchivedScore = result.length > 0 ? result[0].max : 0;\n\n  // Since we cannot run an async query in this simple JSON, this is a placeholder.\n  // Assume a score should be inserted if it is an improvement or the first score.\n\n  // **USER MUST IMPLEMENT EXTERNAL QUERY/FILTERING LOGIC IN A CODE NODE**\n  // If (score > lastArchivedScore) {\n  //   newItems.push({ json: item.json });\n  // }\n  \n  // For now, we pass everything to simulate the structure.\n  newItems.push(item);\n}\n\nreturn newItems;",
        "options": {
          "executeOnce": true
        }
      },
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1250,
        -100
      ],
      "name": "6. Smart Filtering (Only New High Scores)"
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "High_Scores_Archive",
        "schema": "public",
        "options": {
          "mode": "independently"
        },
        "columnDefinition": {
          "columnMap": [
            {
              "column": "player_id",
              "value": "={{$json.player_id}}"
            },
            {
              "column": "machine_id",
              "value": "={{$json.machine_id}}"
            },
            {
              "column": "high_score",
              "value": "={{$json.high_score}}"
            },
            {
              "column": "date_set",
              "value": "={{$json.date_set}}"
            },
            {
              "column": "event_code",
              "value": "={{$json.event_code}}"
            },
            {
              "column": "score_source",
              "value": "='API'"
            },
            {
              "column": "is_approved",
              "value": "=true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1.1,
      "position": [
        1450,
        -100
      ],
      "name": "7. Score Ingestion (High_Scores_Archive)",
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_NAME",
          "name": "YOUR_POSTGRES_CREDENTIAL_NAME"
        }
      }
    },
    {
      "parameters": {
        "query": "SELECT update_combined_leaderboard($1::timestamp, $2::timestamp);",
        "additionalFields": {
          "mode": "singleQuery",
          "queryParams": "={{$json.start_date}},{{$json.stop_date}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1.1,
      "position": [
        1650,
        -100
      ],
      "name": "8. Recalculate (update_combined_leaderboard)",
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_NAME",
          "name": "YOUR_POSTGRES_CREDENTIAL_NAME"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "url": "YOUR_FRONTEND_WEBHOOK_URL_HERE",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1850,
        -100
      ],
      "name": "9. Frontend Trigger / API Publish"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        850,
        -250
      ],
      "name": "4A. New Event: Human in the Middle (HITM)"
    }
  ],
  "connections": {
    "1. Schedule Trigger (Every 10 Mins)": {
      "main": [
        [
          {
            "node": "2. Fetch Data (Stern API)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "2. Fetch Data (Stern API)": {
      "main": [
        [
          {
            "node": "3. Audit & Prepare Data (Extract/Flatten)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "3. Audit & Prepare Data (Extract/Flatten)": {
      "main": [
        [
          {
            "node": "3A. Audit: Save Raw Snapshot",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "4. Event Validation (Check Events Table)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "5. Player/Machine UPSERT",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "4. Event Validation (Check Events Table)": {
      "main": [
        [
          {
            "node": "4A. New Event: Human in the Middle (HITM)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "5. Player/Machine UPSERT": {
      "main": [
        [
          {
            "node": "6. Smart Filtering (Only New High Scores)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "6. Smart Filtering (Only New High Scores)": {
      "main": [
        [
          {
            "node": "7. Score Ingestion (High_Scores_Archive)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "7. Score Ingestion (High_Scores_Archive)": {
      "main": [
        [
          {
            "node": "8. Recalculate (update_combined_leaderboard)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "8. Recalculate (update_combined_leaderboard)": {
      "main": [
        [
          {
            "node": "9. Frontend Trigger / API Publish",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "a4b49ef0-e2e4-46fe-8e14-eb206f597312",
  "meta": {
    "instanceId": "100235c335eb882bd7dc4dc3e300e2d9d5c5fc73acdec7489046f5d3aa6adf7f"
  },
  "id": "NtQN3zvhsYw9Bgej",
  "tags": []
}
